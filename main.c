#include <stdio.h>
#include <stdlib.h>     /* e.g. exit() */
#include <unistd.h>     /* e.g. STDIN_FILENO */
#include <sys/epoll.h>  /* e.g. epoll_wait() */
#include <time.h>       /* e.g. clock_gettime() */
#include <termios.h>    /* e.g. tcsetattr() */
#include <limits.h>     /* e.g. INT_MAX */

/* -----------------------------------------------------------------------------
 * HERE WE INCLUDE THE CODE GENERATED BY THE LUSTRE COMPILER
 */

/* TIME represents time in milliseconds */
#define TIME    int
#define NO_TIME INT_MAX

#include "LUS_step.c"

/* -----------------------------------------------------------------------------
 * MAIN: INITIALIZE EVERYTHING
 */

/* some global variables :-o */
struct termios     MAIN_orig_term;
struct timespec    MAIN_start_time;
struct epoll_event MAIN_epoll_event;
int                MAIN_epoll_fd;
    
void MAIN_init() {
  /* TERMINAL */
  tcgetattr(STDIN_FILENO, &MAIN_orig_term);
  struct termios term;
  tcgetattr(STDIN_FILENO, &term);
  term.c_lflag &= ~(ICANON | ECHO);
  tcsetattr(STDIN_FILENO, TCSANOW, &term);

  /* TIME */
  /* remember the time we started this program */
  clock_gettime(CLOCK_MONOTONIC, &MAIN_start_time);

  /* EPOLL */
  MAIN_epoll_fd = epoll_create1(0);
  if (MAIN_epoll_fd == -1) {
    perror("epoll_create");
    exit(1);
  }
  
  MAIN_epoll_event.events  = EPOLLIN; // read
  MAIN_epoll_event.data.fd = STDIN_FILENO;

  if (epoll_ctl(MAIN_epoll_fd, EPOLL_CTL_ADD, STDIN_FILENO, &MAIN_epoll_event) == -1) {
    perror("epoll_ctl");
    close(MAIN_epoll_fd);
    exit(1);
  }
}

/* -----------------------------------------------------------------------------
 * MAIN: CLEAN UP EVERYTHING
 */

void MAIN_cleanup() {
  /* TERMINAL */
  tcsetattr(STDIN_FILENO, TCSANOW, &MAIN_orig_term);
  
  /* EPOLL */
  close(MAIN_epoll_fd);
}

/* -----------------------------------------------------------------------------
 * MAIN: GET CURRENT TIME IN ms
 */

/* round_up is a boolean that says if we should round up (1=up, 1=down)
   when we convert nanoseconds to milliseconds. */
static inline TIME MAIN_getTIME_ms( int round_up ) {
  struct timespec current_time;
  clock_gettime(CLOCK_MONOTONIC, &current_time);
  return ( (current_time.tv_sec - MAIN_start_time.tv_sec) * 1000
         + (current_time.tv_nsec - MAIN_start_time.tv_nsec + round_up*999999) / 1000000
         ); 
}

/* -----------------------------------------------------------------------------
 * MAIN: WAIT FOR TRIGGER EVENTS
 */

static inline int MAIN_wait( TIME until, char *c ) {
  TIME now = MAIN_getTIME_ms( 1 /* round up */ );
  int wait;
  if ( until >= now )
    wait = until - now;
  else {
    printf("*** no time to wait! (%d > %d)\n", now, until);
    wait = 0;
  }
  
  int nfds = epoll_wait(MAIN_epoll_fd, &MAIN_epoll_event, 1, wait);
  
  if ( nfds > 0 && (MAIN_epoll_event.events & EPOLLIN) ) {
    /* KEY WAS PRESSED */
    if ( read(STDIN_FILENO, c, 1) )
      return 1;
  }
  
  if ( nfds == 0 ) {
    /* TIMEOUT */
    return 0;
  }
  
  perror("epoll_wait");
  MAIN_cleanup();
  exit(1);
}

/* -----------------------------------------------------------------------------
 * MAIN: EVENT LOOP
 */

int main() {
    LUS_state s;
    
    /* INITIALIZE */
    MAIN_init();
    LUS_init(&s);

    /* LOOP */
    TIME now = 0, next = now;
    while ( 1 ) {
      char c;
      /* block until something happens */
      int evt = MAIN_wait( next, &c );
      
      /* prepare for step function */
      now = MAIN_getTIME_ms( 0 /* round down */ );
      
      /* if we have missed our deadline: pretend we haven't */
      if ( next > 0 && now > next ) {
        printf("*** missed deadline! (pretending) [real=%d > logic=%d]\n", now, next);
        now = next;
      }

      /* if we timed out too early: pretend we haven't */
      if ( evt == 0 && now < next ) {
        printf("*** timed out too early! (pretending) [real=%d < logic=%d]\n", now, next);
        now = next;
      }

      /* run step function with logical time 'now' */
      next = LUS_step( &s, now, evt && c=='a', 1, evt && c=='b', 1 );
    }

    /* CLEAN UP */
    MAIN_cleanup();
    return 0;
}

/* -------------------------------------------------------------------------- */

